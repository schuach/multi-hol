#+TITLE: Bereinigung von mehrfach-Holdings
#+NIKOLA_SLUG: multi-hol
#+AUTHOR: Stefan Schuh
#+EMAIL: stefan.schuh@uni-graz.at
#+DATE: 2018-07-23 17:52
#+DESCRIPTION:
#+KEYWORDS:
#+RST: .. status: draft
#+OPTIONS: H:4 num:nil toc:nil ::t |:t ^:nil -:t f:t *:t <:t
#+OPTIONS: tex:t todo:t pri:nil tags:t texht:nil
#+OPTIONS: author:nil creator:nil email:nil date:t
#+EXPORT_FILE_NAME: ~/Schreibtisch/multi-hol.rst


* Ausgangslage und Ziel
  Bei der Datenvorbereitung vor der Migration konnten nicht alle Exemplare einem
  Holding zugeordnet werden, weil in Aleph kein HOL vorhanden war. Infolgedessen
  gibt es Titeldatensätze mit bis zu 678 Holdings mit je einem Item.

  [[file:data/DHB_ITEMS_ohne_HOL_20180717.xlsx][Auswertung (Aleph) der DHB-Datensätze ohne Holding]]

  Es handelt sich um insgesamt 41639 Exemplare an 291 AC-Sätzen und 2394 LB-Sätzen.

  Ziel ist es, die Exemplare an diesen mehrfach-HOLs an ein einzelnes Holding zu
  hängen und die überschüssigen HOLs zu löschen. Dies sollte in einem
  halbautomatischen Prozess passieren (wenn es vollautomatisch ginge, hätten wir
  das wohl schon vorher in Aleph gemacht), weil eine manuelle Bereinigung nicht
  leistbar ist.

*** Angestrebter Workflow
    Eine Bearbeiterin stößt auf einen der betroffenen Datensätze und will ihn
    bereinigen. Dazu sollte sie die folgenden Schritte ausführen müssen:

    1. Das Holding anlegen, an dem die Items im Endeffekt hängen sollen. Wichtig
       ist, dass zumindest Bibliothek, Standort und Grundsignatur eingetragen
       werden, weil über diese ein Abgleich stattfindet. Wenn notwendig mehrere
       HOLs (für Indexe, neue folgen, etc.).
    2. Das Bereinigungsprogramm aufrufen und folgende Daten eingeben:
       - MMS-ID des Titeldatensatzes (*3339)
       - MMS-ID des Zielholdings
     
   
*** Was soll das Script leisten?
    Im Endeffekt sollen alle Items an ihren richtigen Holdings hängen. Dazu
    sollte aus dem Zielholdings die Grundsignatur ausgelesen werden. Nur
    Exemplare, bei denen Bibliothek, Standort und Grundsignatur mit dem Holding
    übereinstimmen, sollten an das jeweilige Holding gehängt werden.

    
***** Mögliche Probleme
      - Für die Bearbeiterin
        - Bei großen Anzahlen an Holdings ist es nicht leicht feststellbar, ob
          mehrere Zielholdings (für neue Folgen, Indizes etc.) angelegt werden
          müssen.
      - Für das Programm
        - Sind Bestellungen mit einem der vorhandenen HOLs verknüpft?
        - Verschiedene Grundsignaturen können mit demselben String anfangen: =I
          123/1= und =I 123/N.F.,1=

* Skript

*** Allgemeine Vorbereitungen
    Dieses Script benötigt Python 3.6 oder höher.
***** Python Virtual environment
      Damit immer die richtigen Versionen des Interpreters und der Module
      verwendet werden, erstellen wir eine Virtual Environment. Dazu führen wir
      in der Shell folgendes aus:

      #+BEGIN_SRC shell
        # Die virtuelle Umgebung erstellen
        python -m venv ~/.venvs/multi-hol

        # Die virtuelle Umgebung aktivieren
        source ~/.venvs/multi-hol/bin/activate
      #+END_SRC


***** Imports etc.
      Als erstes importieren wir verschiedenen Module, die wir brauchen:

      #+NAME: imports
      #+BEGIN_SRC python
      import sys
      import re
      import os
      import keyring
      import datetime
      from requests import Session
      import urllib.parse
      import xml.etree.ElementTree as ET
      import json
      from time import sleep
      from easygui import multenterbox
      import logging
      import getpass
      #+END_SRC

      - =sys= :: um Kommandozeilenargumente entgegenzunehmen (=sys.argv=) oder
                 die Ausführung abzubrechen (=sys.exit=)
      - =os= :: Verzeichnisse anlegen, Dateien löschen, etc.
      - =keyring= :: dient dazu, den API-Key aus dem System-Keyring zu lesen. Für die
                     Distribution ist das natürlich nicht brauchbar. Im Endeffekt wird man hier
                     den Key wohl direkt reinschreiben müssen. Achtung: Dieses
                     Modul gehört nicht zur Standardbibliothek und muss erst via
                     =pip= installiert werden.
      - =requests.Session= :: vereinfacht die API-Calls, indem man die Header
           nicht immer eingeben muss, etc. Achtung: Dieses Modul gehört
           nicht zur Standardbibliothek und muss erst via =pip= installiert
           werden.
      - =urllib.parse= :: wird verwendet, um Strings, die als Teil des URL
                          verwendet werden, richtig zu codieren
      - =xml.etree.ElementTree= :: Nachdem wir nicht viel brauchen, ist es
           einfacher XML zu parsen als die Holdings in pymarc zu lesen, oder in
           JSON umzuwandeln.
      - =json= :: Wir bekommen von der Alma Item-Objekte als JSON. Mit dieser Bibliothek
                  lassen sich JSON-Daten gut manipulieren.
      - =time.sleep= :: um zwischen Löschen am Quell- und Posten am Zielholding
                        zu warten
      - =easygui.multenterbox= :: um von der Benutzerin die MMS-ID von Bibsatz
           und Zielholding zu bekommen
      - =logging= :: um zu loggen
      - =getpass= :: damit wir fürs loggen den Usernamen abfragen können
      
***** DONE Logging
      CLOSED: [2019-01-04 Fr 13:58]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2019-01-04 Fr 13:58]
      :END:
      Falls etwas danebengeht, wollen wir genau wissen, was passiert ist. Daher
      loggen wir alles mit, was passiert. Fast alles -- nachdem wir für den
      Dateinamen die MMS-IDs brauchen holen wir uns selbige schon, bevor wir den
      logger konfigurieren ([[MMS-IDs]]).
      
      #+NAME: logging-conf
      #+begin_src python
        # now = datetime.datetime.now().strftime("%Y%m%d%H%M%S")
        log_file = os.path.join(backup_dir, f"{bib_mms}_{target_hol_id}.log")
        logger = logging.getLogger(__name__)
        logger.setLevel(logging.DEBUG)
        logger.propagate = False

        # add handlers
        log_stream_handler = logging.StreamHandler(sys.stdout)
        log_stream_handler.setLevel(logging.INFO)
        log_stream_handler.setFormatter(
            logging.Formatter('%(levelname)s: %(message)s'))
        logger.addHandler(log_stream_handler)

        log_file_handler = logging.FileHandler(log_file)
        log_file_handler.setLevel(logging.DEBUG)
        log_file_handler.setFormatter(
            logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
        logger.addHandler(log_file_handler)

        # tell us who started the program
        logger.debug(f"Programm gestartet von {getpass.getuser()}.")
      #+end_src
      
***** Voreinstellungen für die APIs
      Nachdem wir viele Calls machen werden, ist es wohl gut, die APIs in
      Variablen mit benannten Platzhaltern zu schreiben, sodass wir dann nur
      noch die jeweiligen IDs einfüllen müssen:
      
      #+NAME: api-strings
      #+BEGIN_SRC python
      # api-url-templates
      base_url = 'https://api-eu.hosted.exlibrisgroup.com/almaws/v1'
      barcode_api = base_url + "/items?item_barcode={barcode}"
      holdings_api = base_url + "/bibs/{mms_id}/holdings"
      bib_api = base_url + "/bibs/{mms_id}"
      item_api = base_url + "/bibs/{mms_id}/holdings/{holding_id}/items"
      #+END_SRC

***** Session, Authentifizierung
      Damit wir nicht bei jedem Aufruf die Header übergeben müssen, ist es
      praktisch, dass die requests-Bibliothek ein Session-Objekt hat.

      #+NAME: session
      #+BEGIN_SRC python
      # session um immer gleiche header zu schicken etc.
      session = Session()
      session.headers.update({
          "accept": "application/json",
          "authorization": f"apikey {api_key}"
      })
      #+END_SRC

      Den API-Key hole ich mit der keyring-Bibliothek aus dem System-Keyring.
      Für eine Deployment-Version muss man den Key wohl hereinschreiben.

      #+NAME: API-key
      #+BEGIN_SRC python
      # get api key from system keyring
      api_key = keyring.get_password("ALMA-API", "BIB-Sandbox").rstrip()
      #+END_SRC
      
*** Verarbeitung      
***** DONE Feststellen, welche Datensätze bearbeitet werden sollen und ein paar Daten auslesen
      CLOSED: [2018-12-10 Mo 16:44]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2018-12-10 Mo 16:44]
      :END:
      Um zu wissen, an welchen Datensätzen gearbeitet werden soll, muss die
      Bearbeiterin die MMS-IDs vom Bibsatz und dem Zielolding eingeben.

      Nachdem Whitespace vorne und hinten entfern wurde, sollte folgendes
      überprüft werden:
      - [X] Beginnt die bib-mms mit 99?
      - [X] Beginnt die hol-mms mit 22?
      - [X] Endet die bib-mms auf 3339?
      #+NAME: MMS-IDs
      #+BEGIN_SRC python
        def get_mmsids(msg=""):
            """Return the MMS-IDs of the bibrecord and the target-holding."""

            if msg == "":
                msg =  "Bitte folgende Daten eingeben."
            else:
                msg = msg

            bib_mms, target_hol_id = multenterbox(msg=msg,
                                                   title="Multi-HOL-Bereinigung",
                                                   fields=["MMS-ID des Bibsatzes", "MMS-ID des Zielholdings"])
            # check the input
            if (not bib_mms.startswith("99")
                    or not bib_mms.endswith("3339")
                    or not target_hol_id.startswith("22")):
                msg = """*** Formaler Fehler in der Eingabe ***

            1. Die MMS-ID des Bibsatzes muss mit "99" beginnen
            2. Die MMS-ID des Bibsatzes muss mit "3339" enden
            3. Die MMS-ID des HOL-Satzes muss mit "22" beginnen
        """
                get_mmsids(msg)
            else:
                return bib_mms, target_hol_id

        # assign values to bib_mms and target_hol_id
        if len(sys.argv) == 3:
            bib_mms = sys.argv[1]
            target_hol_id = sys.argv[2]
        else:
            bib_mms, target_hol_id = get_mmsids()
      #+END_SRC

***** DONE Items holen
      CLOSED: [2018-07-30 Mon 13:54]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2018-07-30 Mon 13:54]
      :END:
      Nachdem die Bearbeiterin uns mit den Identifiern versorgt hat, holen wir
      uns die Item-Liste. Nachdem die API per default nur zehn Items liefert,
      setzen wir das Limit auf die höchstzahl (100). Sollten mehr als 100
      Exemplare vorhanden sein, machen wir mehrere API-Aufrufe mit
      entsprechendem Offset.

      Dazu verwenden wir eine Funktion, die die MMS-IDs des Bibsatzes und eine
      Liste von Item-Objekten zurückgibt.

      #+NAME: API-get-items
      #+BEGIN_SRC python
        def get_items(mms_id, target_hol_id):
            mms_id = mms_id
            outlist = []
            hol_bch = get_bch(target_hol_id)

            # get the item-list from Alma
            item_list = session.get(item_api.format(mms_id=mms_id, holding_id="ALL"),
                                    params={"limit": "100"})

            # TODO check response
            if item_list.status_code == 200:
                item_list = item_list.json()
            else:
                logger.error(f"Fehler beim Holen der Daten: {item_list.text}")
                input("Drücken Sie ENTER um das Programm zu beenden.")
                sys.exit(1)

            # append the items to the list to be returned, if they pass the tests
            logger.debug("get_items(): Items zur outlist hinzufügen")
            for item in item_list["item"]:
                if check_bch(item, hol_bch):
                    outlist.append(item)

            # check if there are more than 100 items
            total_record_count = int(item_list["total_record_count"])
            if total_record_count > 100:
                # calculate number of needed additional calls
                add_calls = total_record_count // 100
                logger.debug(f"get_items(): {total_record_count} items vorhanden, {add_calls} weitere API-calls notwendig.")
                # make the additional calls and add answer to the outlist
                for i in range(add_calls):
                    offset = (i + 1) * 100
                    logger.debug(f"get_items(): additional call {offset}")

                    next_list = session.get(item_api.format(mms_id=mms_id, holding_id="ALL"),
                                            params={"limit": "100", "offset": offset}).json()
                    logger.debug(f"get_items(): weitere items zu outlist hinzufügen (call {offset}/{add_calls})")
                    for item in next_list["item"]:
                        if check_bch(item, hol_bch):
                            outlist.append(item)

            # DONE save the item list to disk
            logger.info("Schreibe Backup.")
            backup_file = os.path.join(backup_dir, f"{mms_id}_{hol_bch[0]}_{hol_bch[1]}_{hol_bch[2].replace('.', '').replace(',', '').replace('/', '').replace(' ', '-')}")
            save_json(outlist, backup_file)
            return outlist
      #+END_SRC

***** DONE Inhaltliche Checks
      CLOSED: [2019-01-04 Fr 09:43]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2019-01-04 Fr 09:43]
      :END:
      Überprüfung, ob die richtigen Signaturen vorhanden sind, etc. Dazu holen
      wir uns zuerst das Zielholding und lesen dort =856 b=, =c= und =h= aus.
        
      #+NAME: get-bch
      #+BEGIN_SRC python
        def get_bch(holding_id):
            hol = session.get(holdings_api + "/" + holding_id, headers = {"accept": "application/xml"})
            try:
                holxml = ET.fromstring(hol.text)
                b = holxml.find('.//*[@tag="852"]/*[@code="b"]').text
                c = holxml.find('.//*[@tag="852"]/*[@code="c"]').text
                h = holxml.find('.//*[@tag="852"]/*[@code="h"]').text
            except:
                logger.exception("Fehler beim Lesen des Zielholdings (XML).")
                print("Ein Fehler ist aufgetreten. Kontrollieren Sie die Log-Datei.")
                input("Drücken Sie ENTER um das Programm zu beenden.")
                sys.exit(1)

            return b, c, h
      #+END_SRC

      Dann schauen wir, ob das Item zum HOL passt, damit nicht
      falschlicherweise Items von anderen Standorten oder mit anderen
      Grundsignaturen umgehängt werden. Subfelder =b= und =c= müssen
      übereinstimmen; die Signatur des Items (genaugenommen von dessen HOL)
      muss mit demselben String anfangen, der in Subfeld =h= steht.

      #+NAME: check-bch
      #+BEGIN_SRC python
        # check if the item fits the target holding's 852 b, c and h

        def check_bch(item, hol_bch):
            """Check if the item fits the target holdings library, location and call number.

            Take an item object (dict) and return True or False."""

            hol_b, hol_c, hol_h = hol_bch

            item_b = item["item_data"]["library"]["value"]
            item_c = item["item_data"]["location"]["value"]
            item_h = item["holding_data"]["call_number"]
            item_alt = item["item_data"]["alternative_call_number"]
            item_h_from_alt = re.sub(r"^.* ; ", "", item_alt)

            bch_check = [False, False, False]

            if hol_b == item_b:
                bch_check[0] = True

            if hol_c == item_c:
                bch_check[1] = True

            if item_h.startswith(hol_h):
                bch_check[2] = True
            elif item_h_from_alt.startswith(hol_h):
                # if the item has already been moved to a false holding because the false
                # call number is a substring of the right one
                bch_check[2] = True

            if False in bch_check:
                return False
            else:
                return True
      #+END_SRC

******* Code für Inhaltliche checks zusammensetzen                 :noexport:
        #+NAME: content-checks
        #+BEGIN_SRC python :noweb yes
          <<get-bch>>
          <<check-bch>>
        #+END_SRC
***** DONE Sicherungen machen
      CLOSED: [2019-01-04 Fr 10:58]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2019-01-04 Fr 10:58]
      :END:
******* DONE Das Sicherungsverzeichnis festlegen
        Hier legen wir das Verzeichnis fest, in das die Sicherungen und reports
        kommen. Falls es nicht vorhanden ist, erstellen wir es.
        
        #+NAME: configure-backup
        #+BEGIN_SRC python
          backup_dir = os.path.join(os.path.expanduser("~"), "Dokumente", "ALMA_multi-hol")
          # make the directory if it does not exist
          if not os.path.exists(backup_dir):
              os.makedirs(backup_dir)
        #+END_SRC

******* DONE Items
        CLOSED: [2019-01-04 Fr 10:58]
        :LOGBOOK:
        - State "DONE"       from "TODO"       [2019-01-04 Fr 10:58]
        :END:
        Nachdem wir ja von =get_items()= eine Liste mit Item-Objekten
        zurückbekommen, schreiben wir diese einfach in eine Datei.

        #+NAME: save-items
        #+BEGIN_SRC python
          def save_json(json_list, filename, count=1):
              """Save JSON-file with a list of items to disk.

              Takes a list of JSON-objects."""

              fname = f"{filename}_{count}.json"
              try:
                  with open(fname, "x") as backup:
                      backup.write(json.dumps(json_list))
              except FileExistsError:
                  save_json(json_list, filename, count + 1)
        #+END_SRC
        
***** DONE Änderungen an den Items machen
      CLOSED: [2018-08-01 Mit 07:14]
      An den Exemplaren sind unter Umständen noch Änderungen vorzunehmen. Diese
      beziehen sich in erste Linie auf die Signaturen.
******* DONE Bearbeitung der Signaturen
        CLOSED: [2018-07-31 Die 11:13]
        Nachdem im Zielholding ja nur die Grundsignatur steht, würde diese
        Information verloren gehen. Daher schreiben wir sie in die Alternative
        Signatur des Exemplars.

        Damit eine etwaig schon vorhandene alternative Signatur nicht
        überschrieben wird, prüfen wir vorher, ob dort schon eine HB-Signatur
        vorhanden ist. Wenn ja, wird die Signatur aus dem Holding nach =" ; "=
        eingefügt.

        #+NAME: set-alt-call-nr
        #+BEGIN_SRC python
          alt_call_nr = item["item_data"]["alternative_call_number"]
          hol_call_nr = item["holding_data"]["call_number"]

          # check if the alternative call number is empty
          if alt_call_nr == "":
              item["item_data"]["alternative_call_number"] = hol_call_nr
              item["item_data"]["alternative_call_number_type"]["value"] = 8
              item["item_data"]["alternative_call_number_type"]["desc"] = "Other scheme"
          elif " ; " in alt_call_nr or hol_call_nr in alt_call_nr:
              pass
          else:
              item["item_data"]["alternative_call_number"] = f"{alt_call_nr} ; {hol_call_nr}"

        #+END_SRC
******* DONE Exemplarstatus leeren
        Wir nutzen diese Gelegenheit auch gleich, um den Exemplarstatus zu
        löschen, der bei diesen Items in Alma nicht mehr notwendig ist.

        #+NAME: clear-item-policy
        #+BEGIN_SRC python
          item["item_data"]["policy"]["desc"] == None
          item["item_data"]["policy"]["value"] == ''
        #+END_SRC

******* DONE Zusammensetzen der einzelnen Änderungen zu einer Funktion
        CLOSED: [2018-08-01 Mit 07:14]
        Damit die einzelnen Änderungen im Script ein bisschen übersichtlicher
        zusammengefasst sind, ziehen wir sie in eine Funktion
        =change_item_information()= zusammen, die wir dann während der
        Bearbeitung aufrufen.

        #+NAME: change-item-information
        #+BEGIN_SRC python :noweb yes
          def change_item_information(item):
              """Make all necessary changes to the item object"""
              # Set the alternative call number
              <<set-alt-call-nr>>

              # clear the item policy
              <<clear-item-policy>>
              return item
        #+END_SRC
***** DONE Items umhängen und Holdings löschen
      CLOSED: [2019-01-04 Fr 09:39]
      :LOGBOOK:
      - State "DONE"       from "TODO"       [2019-01-04 Fr 09:39]
      :END:
      Das Umhängen des Exemplars sollte der letzte Schritt sein. Vorher sollten
      alle Checks laufen und das Item entsprechend angepasst werden (z. B. die
      HOL-Signatur in die =alternative_call_number= schreiben).

      Um ein Exemplar umzuhängen, muss man es erst löschen und dann am
      Zielholding anhängen. Zuerst löschen deswegen, weil sonst der Barcode
      schon vorhanden ist und einen Error verursacht.

      Um ein Exemplar also umzuhängen, sind folgende Schritte notwendig:
      1. Das Exemplar sichern. Das sollten wir ohnehin beim Abrufen der
         Exemplare schon gemacht haben. Die nötigen Funktionen finden sich im
         [[Sicherungen machen][entsprechenden Kapitel]].
      2. Das Exemplar via DELETE-request löschen. Wir übergeben den Parameter
         "holdings=delete", um das Holding gleich mit zu löschen.
      3. Das Exemplar mit einem POST-request ans Zielholding hängen.

      Der erste Schritt, wird oben abgearbeitet, die beiden weiteren werden in
      der Funktion =move_item()= abgehandelt:

      #+NAME: move-item
      #+BEGIN_SRC python :noweb yes
        def move_item(item, bib_mms, target_hol_id):
            """Move items to other holding and delete source-holding"""
            # delete the items, but prevent the target-hol from being deleted
            barcode = item["item_data"]["barcode"]
            title = item["bib_data"]["title"]
            target = item_api.format(mms_id=bib_mms, holding_id=target_hol_id)
            if not target_hol_id in item["link"]:
                logger.debug(f"move_item(): lösche {barcode}")
                delete_item_response = session.delete(item["link"], params={"holdings": "delete"})
            else:
                logger.debug(f"move_item(): lösche {barcode}")
                delete_item_response = session.delete(item["link"], params={"holdings": "retain"})

            if not delete_item_response.status_code == 204:
                logger.error(f"move_item(): löschen fehlgeschlagen bei {barcode}. {delete_item_response.text}")
                return

            # post the item. Wait for 1 second before that, so that Alma can update the
            # barcode index. Try again, if barcode index is not updated.
            sleep(1)
            tries = 0
            logger.debug(f"move_item(): POST von {barcode}")
            post_item_response = session.post(target, json=item).json()
            while "errorsExist" in post_item_response:
                if tries > 5:
                    error = post_item_response["errorList"]["error"][0]["errorMessage"]
                    # errors.append([bib_mms, barcode, title, error])
                    logger.error(f"move_item(): {barcode} Fünfter POST-Versuch fehlgeschlagen, Abbruch.")
                    break
                elif post_item_response["errorList"]["error"][0]["errorCode"] == "401873":
                    # if the error is an existing barcode, try again
                    logger.info(f"move_item(): {barcode}: weiterer POST-Versuch ({tries + 1}x)")
                    sleep(1)
                    post_item_response = session.post(target, json=item).json()
                    tries += 1
                else:
                    error = post_item_response["errorList"]["error"][0]["errorMessage"]
                    (f"move_item(): unerwarteter Fehler bei POST {error}")
                    break
      #+END_SRC

******* Problem mit der API # 00580797                  :Salesforce:noexport:
Dear Support Team,

we need to move items from one holding to another via API. As I understand it, the way to go is to delete the item in one place and create it again by POSTing it at the target holding -- if there is a better/more efficient way, I'm glad to hear it.

When doing so, I get an HTTP 200 for evey item I post and the API returns the item object for every item. So I'm thinking everything went right. 

But it gets funky:

When looking in Alma, there's only one item on this holding (the first one I have POSTed), but there should be several. So I try to get the item list for all items on that bib:

GET https://api-eu.hosted.exlibrisgroup.com/almaws/v1/bibs/990011168120203339/holdings/ALL/items

Response:
{"item":[{"bib_data":{"mms_id":"990011168120203339","title":"Kaerntner Gemeindeblatt","author":null,"issn":null,"isbn":null,"complete_edition":"","network_number":["(Aleph)001116812UBG01","(AT-UBG)LB00780006","LB00780006"],"link":"https://api-eu.hosted.exlibrisgroup.com/almaws/v1/bibs/990011168120203339"},"holding_data":{"holding_id":"22326791880003339","call_number_type":{"value":"8","desc":"Other scheme"},"call_number":"Testsig","accession_number":"","copy_id":"","in_temp_location":false,"temp_library":{"value":null,"desc":null},"temp_location":{"value":null,"desc":null},"temp_call_number_type":{"value":"","desc":null},"temp_call_number":"","temp_policy":{"value":"","desc":null},"link":"https://api-eu.hosted.exlibrisgroup.com/almaws/v1/bibs/990011168120203339/holdings/22326791880003339"},"item_data":{"pid":"23326791890003339","barcode":"DC-25388","creation_date":"2018-08-01Z","modification_date":"2018-08-01Z","base_status":{"value":"1","desc":"Item in place"},"physical_material_type":{"value":"ISSBD","desc":"Bound Issue"},"policy":{"value":"60","desc":"Kopiebestellung"},"provenance":{"value":"","desc":null},"po_line":"","is_magnetic":false,"arrival_date":"1999-04-01Z","year_of_issue":"","enumeration_a":"1971","enumeration_b":"2","enumeration_c":"","enumeration_d":"","enumeration_e":"","enumeration_f":"","enumeration_g":"","enumeration_h":"","chronology_i":"1971","chronology_j":"","chronology_k":"","chronology_l":"","chronology_m":"","description":"1971,2","receiving_operator":"import","process_type":{"value":"","desc":null},"library":{"value":"BDEPO","desc":"Depotbibliothek"},"location":{"value":"DHB20","desc":"Depot HB20"},"alternative_call_number":"HB20-918","alternative_call_number_type":{"value":"8","desc":"Other scheme"},"storage_location_id":"","pages":"","pieces":"","public_note":"","fulfillment_note":"","internal_note_1":"FH03 - I 380584, 1971,2. 1971 :: KKD","internal_note_2":"","internal_note_3":"","statistics_note_1":"O#RAK#2014","statistics_note_2":"","statistics_note_3":"","requested":null,"edition":null,"imprint":null,"language":null,"physical_condition":{"value":null,"desc":null}},"link":"https://api-eu.hosted.exlibrisgroup.com/almaws/v1/bibs/990011168120203339/holdings/22326791880003339/items/23326791890003339"}],"total_record_count":1}

Hmm. Why is there only one item, when I got confirmation that everything went good -- the API returned HTTP 200 and the item object for every item.

It gets even more interesting: When retrieving the items for the specific holding (the only one, I might add), this happens:

GET https://api-eu.hosted.exlibrisgroup.com/almaws/v1/bibs/990011168120203339/holdings/22326792100003339/items

Response:
{"total_record_count":14}

That's all of the response -- no omissions. Total record count of 14, but no item list?

Best of it all: I can retrieve the individual items via API though (I know where to look for, as I got the item object as response for the POST request).

For example:
GET https://api-eu.hosted.exlibrisgroup.com/almaws/v1/bibs/990011168120203339/holdings/22326791910003339/items/23326791770003339

This returns the corresponding item.

What am I doing wrong?

If there's an easyer way to move items from one holding to another, I'm happy to be educated about that too.

Best regards
Stefan
      
*** Alles Zusammensetzen
***** Das Modul
      #+BEGIN_SRC python :noweb yes :tangle multi_hol/multi_hol.py
        <<imports>>

        # Get the users input
        <<MMS-IDs>>
        # set up the backup
        <<configure-backup>>
        #configure logging
        <<logging-conf>>

        # get everything ready for making the API-Calls
        <<api-strings>>
        <<API-key>>
        <<session>>

        # function for backing up JSON to disk
        <<save-items>>

        # functions for checking the api-responses
        <<content-checks>>

        # Get the items
        <<API-get-items>>

        # Change item information like call numbers etc.
        <<change-item-information>>

        # Move the item to the target holding
        <<move-item>>

        def main(bib_mms, target_hol_id):

            logger.info("Hole Daten von Alma ...")
            item_list = get_items(bib_mms, target_hol_id)
            item_count = len(item_list)
            logger.info(f"Zu bearbeitende Exemplare: {item_count}")

            for idx, item in enumerate(item_list):
                logger.info(f"Exemplar {idx + 1} von {item_count}: {item['item_data']['barcode']}")
                logger.info("Bearbeite Exemplardaten ...")
                change_item_information(item)

                # richtigen Aufruf schreiben
                logger.info("Verschieben an Zielholding ...")
                move_item(item, bib_mms, target_hol_id)

        main(bib_mms, target_hol_id)
        input("Verarbeitung abgeschlossen!\nDrücken Sie ENTER um das Programm zu verlassen.")
      #+END_SRC
         
*** Tests
    Natürlich will das alles gut getestet sein.

    Beispieldatensätze in der Sandbox:
    - 990011505800203339: 10 Hols, keine alternative Signatur
    - 990011608060203339: 10 Hols, alternative Signatur
    - 990006489880203339: 106 Hols, alternative Signatur
      
    Zuerst holen wir mal alle Exemplare und speichern sie, sodass wir mir
    schnell den Ausgangszustand wiederherstellen können.

    #+BEGIN_SRC python :noweb yes :tangle tests/test_multi_hol.py
      import pytest
      from multi_hol.multi_hol import *
      # with alternative call number
      with open("tests/testdata/10items_alt.json") as fh:
          items_alt = json.load(fh)["item"]
      # without alternative call number
      with open("tests/testdata/10items_no_alt.json") as fh:
          items_no_alt = json.load(fh)["item"]

      item_alt = items_alt.pop(0)
      item_no_alt = items_no_alt.pop(0)

      def test_get_item():
          items = get_items("990006489880203339")
          assert len(items) == 106
          barcodes = []
          for item in items:
              barcodes.append(item["item_data"]["barcode"])
          assert len(items) == len(barcodes)
          assert len(set(barcodes)) == len(barcodes)

      def test_get_bch():
          assert get_bch("22312549980003339") == ("BDEPO", "DHB40", "II 140137, 219,Ind. 1879")

      def test_change_item_info():
          # load items
          # with alternative call number
          with open("tests/testdata/10items_alt.json") as fh:
              items_alt = json.load(fh)["item"]
          # without alternative call number
          with open("tests/testdata/10items_no_alt.json") as fh:
              items_no_alt = json.load(fh)["item"]

          item_alt = items_alt.pop(0)
          item_no_alt = items_no_alt.pop(0)

          assert change_item_information(item_alt)["item_data"]["alternative_call_number"] == "HB20-918 ; I 380584/1971,2"
          assert change_item_information(item_no_alt)["item_data"]["alternative_call_number"] == "I 380010/48"
          assert change_item_information(item_no_alt)["item_data"]["alternative_call_number_type"]["value"] == 8
          assert change_item_information(item_no_alt)["item_data"]["alternative_call_number_type"]["desc"] == "Other scheme"


    #+END_SRC

* API-Dokumentation
  - [[https://developers.exlibrisgroup.com/alma/apis/bibs/DELETE/gwPcGly021om4RTvtjbPleCklCGxeYAfEqJOcQOaLEvNcHQT0/ozqu3DGTurs/Xx+GZLELMQamEGJL0f6Mjkdw==/af2fb69d-64f4-42bc-bb05-d8a0ae56936e][Withdraw Item]]
  - [[https://developers.exlibrisgroup.com/alma/apis/bibs/POST/gwPcGly021om4RTvtjbPleCklCGxeYAfEqJOcQOaLEvNcHQT0/ozqu3DGTurs/XxIP4LrexQUdc=/af2fb69d-64f4-42bc-bb05-d8a0ae56936e][Create Item]]
  - [[https://developers.exlibrisgroup.com/alma/apis/xsd/rest_item.xsd][Item-Object]]

* Dokumentation für BearbeiterInnen
*** Allgemeines
    In Alma gibt es Datensätze (größenteils Zeitschriften und Reihen), an denen
    für jedes Exemplar ein Holding vorhanden ist, obwohl eigentlich die ganzen
    Exemplare an einem oder wenigen Holdings hängen sollten. Meistens ist das
    der Fall, weil in Aleph kein Holding an diesem Titel vorhanden war. Nachdem
    jedes Exemplar eine andere Signatur hatte (=I 12345/1=, =I 12345/2=, usw.),
    wurde bei der Migration für jedes einzelne ein eigenes Holding gebildet. Das
    wollen wir nun bereinigen.

    Nachdem das bei mehr als 40.000 Exemplaren intellektuell nicht zu leisten
    ist,gibt es zu diesem Zweck ein kleines Programm, dass Sie dabei
    unterstützt.

    Der Ablauf für Sie schaut folgendermaßen aus:

    - Zielholding identifizieren/erstellen
    - Programm aufrufen
    - Falls mehrere Grundsignaturen vorhanden (z. B. "N.F."), mit nächster
      Grundsignatur wiederholen, bis alles Exemplare richtig hängen
    - Falls noch nicht geschehen, die Informationen in den Holdings ergänzen,
      die noch fehlen

*** Zielholding identifizieren/erstellen
    Um ein Zielholding zu identifizieren bzw. zu erstellen, müssen wir klären,
    was wir in diesem Zusammenhang unter dem Begriff /Grundsignatur/ verstehen:

    Unter *Grundsignatur* verstehen wir den Teil einer Signatur, der /mehreren
    Exemplaren einer Zählfolge gemeinsam/ ist. Z. B. =I 156715=, aber auch =I
    156715/N.F.= oder =I 156715/3.Ser.=. Diese Unterscheidung ist wichtig, weil
    die Zuordnung der Exemplare an ein Zielholding unter anderem dadurch
    passiert, dass die Signatur im zu bereinigenden Holding gleich anfängt, wie
    die im Zielholding.
